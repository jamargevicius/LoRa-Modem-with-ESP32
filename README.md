# LoRa Modem experience with ESP32

I've had problems with the LoRa modem hanging during long data acquisitions, and decided to write the code without using the LoRa.h API. The LoRa.h and LoRa.cpp are very complete, but is a scatter-gram of code and hard to troubleshoot a problem with.  So the code I'm including in this repository is full of register writing and reading of the modem, but it does give a better idea of what is happening.  

I built transmitter boxes and a receiver box (small 6"x4"x3" boxes).  They are designed to be used remotely where there is no WiFi access (though the code supports WiFi), and I run them from a Lithium battery (one that doesn't shut off when the current drain is very low, as it will be when these boxes are "asleep").  These boxes have 8 position DIP switches in them to allow various features, such as using WiFi or not, how often to send packets, power of the transmitter, etc - see code).  The boxes have a Real Time Clock (RTC) modeule in them, and the Receiver has an SD card (again, remote operation requires some place to store data for months). An objective has been to minimize power consumption, thus the ESP32 is put to sleep when not being used, and the modem on the transmitters are put to sleep when not active. When the ESP32 wakes up, it reboots and thus can re-read the switches to determine if any desired feature has changed. 

The transmit code puts the ESP and modem to sleep, and wakes up hourly (or every minute depending on the switches), by an interrupt from the RTC. When it wakes up, it collects data from the soil moisture and temp sensors, as well as the temp/pressure/humidity from the BME280 sensor and light levels from the lux sensor. It forms the packet, writes it to the fifo in the modem, and sends off the packet ... then everything goes to sleep waiting for the next RTC interrupt. 

On the receiver, the code puts the ESP32 to sleep, but the modem is in Continuous receive mode. On receipt of a packet, it wakes up the ESP32 via a generated "Rx Done" interrupt, reads the time of the RTC, and writes the time-stamped contents to an SD card.

To further reduce power consumption, I used a switch to detemine whether the OLED was being used (i.e. displaying stuff) or not.  One could just take the OLED out of the circuit instead, especially for very long-term monitoring. When the ESP32 wakes up, it re-reads the switches, so this is the opportunity to change things (i.e. between packets sends/receives). 

My code is a *horror* to a *real* software person. ... sorry, I'm from a hardware background and like things clear, compact and not scattered in tons of other files (I like one (1) D-sized drawing, and hate the 10 page version of A sized ones to describe a circuit, for example --- very old school!).  This makes the code "stringy", long, and frustrating to people used to seeing brackets in traditional places, etc. If you hate the code, blame complexity, not me ;-)  Engineers love complexity, but I always tried to design under the mantra "The simple solution wins"  (having all the #defines in the single files from the LoRa.cpp is not elegant, but it made it easier to figure out what was causing my very intermittant hangups). 

So, after much pulling of hair, the cause of "hanging of the LoRa modem" has been hardware related - at least that is what I concluded as I couldn't find any reason in the original LoRa.h - based code I had previously used.  The modem's reset pin is very sensitive to glitches, and was a major cause for hanging.  I solved this by putting an RC circuit between the ESP32 and the modem's nReset pin (1 K resistor straight from the ESP to the modem, with a 0.01uF cap at the modem to +3.3V; an alternative might be to put a 1K resistor to +3.3v on the reset pin but it is not as certain to reduce glitches as an RC circuit). The causes of the glitches were: 1) recovery from sleep mode by the ESP (this was on the Tx boxes), 2) ocassional dropout of the Li battery packs when the current got very low during sleep - this affected the ESPs but going into brown-out at the wrong time), and 3) low voltage at the 5-to-3.3v regulator in the ESP32 module which I solved this by shorting out the protection diode in series with the regulator and the +5V souurce (the specs on the regulator state a minimum of 4.5 volts, which after the schottkey diode, the voltage was as low as 4.1 volts  - this depends very much on ythe lithium battery being used - note that lithium cells don't put out voltages convenient for 5.0 supplies, so they have circuitry in there to lower it; they're designed for cell-phone charging mostly, not glitche-sensitive microcontrollers !)
